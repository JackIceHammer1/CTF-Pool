open the file in ghidra you can look through the funcions there are 2 main functions the main() and check_pass()
you will also see 3 global arrays flag_list[], ascii_string[], and converted_chars[]
ascii_string[] = "abcdefghijklmnopqrstuvwxyz1234567890{}_"
converted_chars[] = empty
if you look at the check_pass() function you will see an array called correst_offset[]
the data in correct_offset[] is stored in local_c8[0] through local_c8[32]
if you take the data that is stored and take it from hex to decimal you will get 
[25, 1, 2, 33, 5, 36, 11, 4, 14, 13, 28, 34, 13, 21, 17, 17, 1, 4, 5, 6, 35, 2, 36, 16, 19, 2, 1, 34, 16, 28, 24, 19]
  
The check password function is 

do {
    if (0x1f < local_1c) {
      for (local_24 = 0; local_24 < 0x20; local_24 = local_24 + 1) {
        iVar1 = aiStack_148[local_24];
        iVar2 = *(int *)(flag_list + (long)local_24 * 4);
        if (iVar1 < iVar2) {
          aiStack_1c8[local_24] = iVar2 - iVar1;
        }
        else {
          aiStack_1c8[local_24] = iVar2 + (0x28 - iVar1);
        }
      }
      for (local_28 = 0; local_28 < 0x20; local_28 = local_28 + 1) {
        converted_chars[local_28] = ascii_string[*(int *)(flag_list + (long)local_28 * 4)];
      }
      local_2c = 0;
      while( true ) {
        if (0x1f < local_2c) {
          return 1;
        }
        if (aiStack_1c8[local_2c] != local_c8[local_2c]) break;
        local_2c = local_2c + 1;
      }
      return 0;
    }
    for (local_20 = 0; uVar4 = (ulong)local_20, sVar3 = strlen(ascii_string), uVar4 < sVar3;
        local_20 = local_20 + 1) {
      if (ascii_string[local_20] == *(char *)(param_1 + local_1c)) {
        aiStack_148[local_1c] = local_20;
        break;
      }
    }
    local_1c = local_1c + 1;
  } while( true );
}

this takes the users input and turns it into numbers base on each leter position in asccii_string
so hello would be [7, 4, 11, 11, 14]
it does this for your full 32 charater guess then checks how far off each letter is from the ecnrypted flag stored in flag_list[]
flag_list[] = 9, 15, 22, 10, 9, 36, 22, 15, 38, 24, 2, 15, 17, 38, 21, 38, 5, 21, 23, 14, 8, 8, 38, 23, 19, 13, 12, 38, 29, 34, 28, 37
so if you used hello the 7 is 2 off of the 9 the 4 is 11 off of the 15 ect. if the user number is bigger it goes to 40 and back around so the 11 to the 10 becomes 39
so the off set of the input hello becomes [2, 11, 11, 39, 35] note: the user input must be 32 characters long
the it goes one number at a time and compares it to the correct offset if they are not equal it becomes false and the password is wrong

the correct flag is put in the converted_chars[] arrary if you run this in a debugger like GDB you can make a break point at the end of the check_pass function
then run it and print the register

or you can convert it with the ascii_string 
i wrote a script to do it 
i wrote this python 
flag_list = [9, 15, 22, 10, 9, 36, 22, 15, 38, 24, 2, 15, 17, 38, 21, 38, 5, 21, 23, 14, 8, 8, 38, 23, 19, 13, 12, 38, 29, 34, 28, 37]
ascii_string = "abcdefghijklmnopqrstuvwxyz1234567890{}_"

flag = ''.join(ascii_string[num] for num in flag_list)
print(flag)

which gives the flag jpwkj{wp_ycpr_v_fvxoii_xtnm_493} 
this is encrypted and the key to decrypt it is the correct password.

Finding the correct password

in the main function it asks for a password the password must be 32 characters long
then it puts the guess in the check password function 
then takes it and uses the offset method from before
if the offset is the same as the correct offset, that will print correct.

to find the right password you can use the correct offset and count back from the ascii list 
i made this python script to do it 

flag = "jpwkj{wp_ycpr_v_fvxoii_xtnm_493}"
correst_offset = [25, 1, 2, 33, 5, 36, 11, 4, 14, 13, 28, 34, 13, 21, 17, 17, 1, 4, 5, 6, 35, 2, 36, 16, 19, 2, 1, 34, 16, 28, 24, 19]
ascii_string = "abcdefghijklmnopqrstuvwxyz1234567890{}_"
decoded_flag = ""

flag_num = []
list3 = []
list4 = []
for i in flag:
    flag = ascii_string.find(i)
    flag_num.append(flag)
for i in range(32):
    offset = correst_offset[i]
    num = flag_num[i]
    if offset > num:
        x = num
        y = offset - x
        z = 40 - y
        list3.append(z)
    else:
        x = num - offset
        list3.append(x)

for i in range(32):
    x = list3[i]
    z = ascii_string[x]
    list4.append(z)
print(''.join(list4), end='')

this will output youreallylovereversingchallenges
if we try this as the password, it works.

encrypted flag = jpwkj{wp_ycpr_v_fvxoii_xtnm_493}
password = youreallylovereversingchallenges

if we take these and decoded them using the password as they key
using the vigenere cipher we can decode them to get the flag

lbctf{we_need_a_better_flag_493}
